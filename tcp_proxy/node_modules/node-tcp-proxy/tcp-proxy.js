var net = require("net");

function uniqueKey(socket) {
    var key = socket.remoteAddress + ":" + socket.remotePort;
    return key;
}

var remoteAddressCount = {};
const MAX_IP = parseInt(process.env.MAX_IP);

function TcpProxy(proxyPort, serviceHost, servicePort, options) {
    this.proxyPort = proxyPort;
    this.serviceHost = serviceHost;
    this.servicePort = servicePort;
	this.options = options;
    this.proxySockets = {};

    this.createProxy();
}

function ip2netSecion(ip)   {
    let [a, b, c, d] = ip.split(".");
    return a + "." + b + "." + c;
}

TcpProxy.prototype.createProxy = function() {
    this.log("proxy listening at port " + this.proxyPort);
    var proxy = this;

    let logInterval = process.env.IP_STAT_INT ? parseInt(process.env.IP_STAT_INT) : undefined;
    setInterval(() => {
        proxy.log(remoteAddressCount);
    }, logInterval ? logInterval * 1000 : 60000);
    proxy.log("IP limit is set to " + MAX_IP);
    
    proxy.server = net.createServer(function(proxySocket) {
        var key = uniqueKey(proxySocket);
        let ip = ip2netSecion(proxySocket.remoteAddress);
        

        if (remoteAddressCount[ip]) {
            proxy.log("Connected from " + ip);
            remoteAddressCount[ip] ++;
        } else {
            if (MAX_IP != 0 && Object.keys(remoteAddressCount).length >= MAX_IP)   {
                proxy.log("Max number dected, destroy socket from " + ip);
                proxySocket.destroy();
                return;
            } else {
                proxy.log("Connected from " + ip);
                remoteAddressCount[ip] = 1;
            }
        }
        proxy.proxySockets[key] = proxySocket;
        
        var connected = false;
        var buffers = [];

        var serviceSocket = new net.Socket();
        serviceSocket.connect(proxy.servicePort, proxy.serviceHost, function() {
            connected = true;
            if (buffers.length > 0) {
                for (var i = 0; i < buffers.length; i++) {
                    serviceSocket.write(buffers[i]);
                }
            }
        });
        serviceSocket.on("data", function(data) {
            proxySocket.write(data);
        });
        serviceSocket.on("close", function(hadError) {
            proxy.log("Disconnected from: " + proxySocket.remoteAddress);
            endProxySocket(proxySocket.remoteAddress);
            proxySocket.destroy();
        });
        serviceSocket.on("error", function(e) {
            proxy.log("service socket error");
            proxy.log(e);
            proxy.log("  ending proxy socket");
            
            proxy.log("Disconnected from: " + proxySocket.remoteAddress);
            endProxySocket(proxySocket.remoteAddress);
            proxySocket.destroy();
        });

        proxySocket.on("error", function(e) {
            proxy.log("proxy socket error");
            proxy.log(e);
            proxy.log("Disconnected from: " + proxySocket.remoteAddress);
            endProxySocket(proxySocket.remoteAddress);
            proxySocket.destroy();
        });
        proxySocket.on("data", function(data) {
            if (connected) {
                serviceSocket.write(data);
            } else {
                buffers[buffers.length] = data;
            }
        });
        proxySocket.on("close", function(hadError) {
            delete proxy.proxySockets[uniqueKey(proxySocket)];
            serviceSocket.destroy();
        });
    }).listen(proxy.proxyPort, proxy.options.hostname);
};

function endProxySocket(ipAddr) {
    let ip = ip2netSecion(ipAddr);
    if (remoteAddressCount[ip]) {
        remoteAddressCount[ip] --;
        if (remoteAddressCount[ip] === 0)   {
            delete remoteAddressCount[ip];
        }
    }
}

TcpProxy.prototype.end = function() {
    this.log("terminating proxy");
    this.server.close();
    for (var key in this.proxySockets) {
        this.proxySockets[key].destroy();
    }
    this.server.unref();
};

TcpProxy.prototype.log = function(msg) {
    if (!this.options || !this.options.quiet) {
        console.log(msg);
    }
};

module.exports.createProxy = function(proxyPort,
serviceHost, servicePort, options) {
    return new TcpProxy(proxyPort, serviceHost, servicePort, options);
};
